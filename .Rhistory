any_high_moe   = sum(high_moe_flag,   na.rm = TRUE),
pct_flagged    = round(100 * any_high_moe / total_tracts, 1),
.groups = "drop"
) %>%
dplyr::arrange(dplyr::desc(pct_flagged))
knitr::kable(
flags_by_county,
digits = 1,
caption = "Tracts with MOE% > 15% by county (counts and % of tracts flagged)"
)
# Create a summary table using your county reliability data
# Include: county name, median income, MOE percentage, reliability category
# Add a new column with algorithm recommendations using case_when():
# - High Confidence: "Safe for algorithmic decisions"
# - Moderate Confidence: "Use with caution - monitor outcomes"
# - Low Confidence: "Requires manual review or additional data"
# Format as a professional table with kable()
# ---- Decision framework table (minimal + robust) ----
library(dplyr)
library(knitr)
decision_tbl <- county_reliability %>%
# keep rows where we can actually decide something
filter(!is.na(med_incomeE), !is.na(income_moe_pct)) %>%
# If your data already has `reliability`, we’ll use it; otherwise derive it from MOE%
mutate(
reliability = case_when(
!is.na(reliability) ~ reliability,
income_moe_pct <= 5     ~ "High Confidence",
income_moe_pct <= 10    ~ "Moderate Confidence",
TRUE                    ~ "Low Confidence"
),
# Map reliability -> implementation recommendation
recommendation = case_when(
reliability == "High Confidence"      ~ "Safe for algorithmic decisions",
reliability == "Moderate Confidence"  ~ "Use with caution - monitor outcomes",
reliability == "Low Confidence"       ~ "Requires manual review or additional data",
TRUE                                  ~ "Review needed"
),
# Pretty formatting for display only
`Median income ($)` = formatC(med_incomeE, format = "f", digits = 0, big.mark = ","),
`Income MOE %` = sprintf("%.1f%%", income_moe_pct),
# Order rows by reliability (High → Moderate → Low)
reliability = factor(reliability, levels = c("High Confidence","Moderate Confidence","Low Confidence"))
) %>%
transmute(
County = county,
`Median income ($)`,
`Income MOE %`,
Reliability = reliability,
Recommendation = recommendation
) %>%
arrange(Reliability, County)
knitr::kable(
decision_tbl,
caption = "Decision Framework for Algorithm Implementation (ACS 2022 5-year)"
)
# ---- Decision framework table (minimal + robust) ----
library(dplyr)
library(knitr)
decision_tbl <- county_reliability %>%
# keep rows where we can actually decide something
filter(!is.na(med_incomeE), !is.na(income_moe_pct)) %>%
# If your data already has `reliability`, we’ll use it; otherwise derive it from MOE%
mutate(
reliability = case_when(
!is.na(reliability) ~ reliability,
income_moe_pct <= 5     ~ "High Confidence",
income_moe_pct <= 10    ~ "Moderate Confidence",
TRUE                    ~ "Low Confidence"
),
# Map reliability -> implementation recommendation
recommendation = case_when(
reliability == "High Confidence"      ~ "Safe for algorithmic decisions",
reliability == "Moderate Confidence"  ~ "Use with caution - monitor outcomes",
reliability == "Low Confidence"       ~ "Requires manual review or additional data",
TRUE                                  ~ "Review needed"
),
# Pretty formatting for display only
`Median income ($)` = formatC(med_incomeE, format = "f", digits = 0, big.mark = ","),
`Income MOE %` = sprintf("%.1f%%", income_moe_pct),
# Order rows by reliability (High → Moderate → Low)
reliability = factor(reliability, levels = c("High Confidence","Moderate Confidence","Low Confidence"))
) %>%
transmute(
County = county,
`Median income ($)`,
`Income MOE %`,
Reliability = reliability,
Recommendation = recommendation
) %>%
arrange(Reliability, County)
knitr::kable(
decision_tbl,
caption = "Decision Framework for Algorithm Implementation (ACS 2022 5-year)"
)
# Load required packages (hint: you need tidycensus, tidyverse, and knitr)
# Set your Census API key
# Choose your state for analysis - assign it to a variable called my_state
library(tidycensus)
library(tidyverse)
library(knitr)
library(stringr)
options(tigris_use_cache = TRUE)
my_state <- "New York"
acs_year <- 2022
# Write your get_acs() code here
# Clean the county names to remove state name and "County"
# Hint: use mutate() with str_remove()
# Display the first few rows
# ---- 2.1 County-level data (ACS 2022 5-year) ----
vars <- c(
med_income = "B19013_001",  # Median household income
total_pop  = "B01003_001"   # Total population
)
county_raw <- get_acs(
geography = "county",
variables = vars,
year = 2022,
survey = "acs5",
state = my_state,
output = "wide"
)
county <- county_raw %>%
mutate(
county = NAME %>%
stringr::str_remove(",\\s*.*$") %>%  # drop ", State"
stringr::str_remove("\\s*County$")   # drop trailing "County"
) %>%
select(
county, GEOID,
med_incomeE, med_incomeM,
total_popE,  total_popM
)
knitr::kable(
head(county, 10),
caption = paste("County-level ACS (2022 5-year) for", my_state),
digits = 0
)
# Calculate MOE percentage and reliability categories using mutate()
# Create a summary showing count of counties in each reliability category
# Hint: use count() and mutate() to add percentages
# ---- 2.2A: compute MOE% for median income ----
county_moe <- county %>%
dplyr::mutate(
income_moe_pct = dplyr::if_else(
!is.na(med_incomeE) & med_incomeE > 0 & !is.na(med_incomeM),
100 * med_incomeM / med_incomeE,
NA_real_
)
)
# peek at just the columns we care about
knitr::kable(
county_moe %>%
dplyr::select(county, med_incomeE, med_incomeM, income_moe_pct) %>%
head(10),
caption = "MOE% for median income (first 10 counties)",
digits = c(0, 0, 0, 1)
)
# ---- 2.2B: add reliability category ----
county_reliability <- county_moe %>%
dplyr::mutate(
reliability = dplyr::case_when(
is.na(income_moe_pct) ~ "Unavailable",
income_moe_pct < 5    ~ "High Confidence",
income_moe_pct <= 10  ~ "Moderate Confidence",
income_moe_pct > 10   ~ "Low Confidence"
)
)
# quick preview
knitr::kable(
county_reliability %>%
dplyr::select(county, med_incomeE, med_incomeM, income_moe_pct, reliability) %>%
head(10),
caption = "Income MOE% + reliability category (first 10)",
digits = c(0, 0, 0, 1)
)
# ---- 2.2C: unreliable flag + summary table ----
county_reliability <- county_reliability %>%
dplyr::mutate(unreliable = income_moe_pct > 10)
rel_summary <- county_reliability %>%
dplyr::count(reliability) %>%
dplyr::mutate(pct = round(100 * n / sum(n), 1)) %>%
dplyr::arrange(match(reliability, c("High Confidence","Moderate Confidence","Low Confidence","Unavailable")))
knitr::kable(rel_summary, caption = "County reliability categories", digits = 1)
# Create table of top 5 counties by MOE percentage
# Format as table with kable() - include appropriate column names and caption
# ---- 2.3: Top 5 counties by income MOE% ----
top5_uncertainty <- county_reliability %>%
dplyr::filter(!is.na(income_moe_pct)) %>%                 # ignore rows where MOE% couldn't be computed
dplyr::arrange(dplyr::desc(income_moe_pct)) %>%           # highest MOE% first
dplyr::slice(1:5) %>%                                     # top 5
dplyr::transmute(                                         # select + rename for presentation
county,
`Median income ($)` = med_incomeE,
`Income MOE ($)`    = med_incomeM,
`Income MOE %`      = sprintf("%.1f%%", income_moe_pct),
Reliability        = reliability
)
knitr::kable(
top5_uncertainty,
caption = "Top 5 counties by median income MOE% (ACS 2022 5-year)"
) %>%
kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
# Use filter() to select 2-3 counties from your county_reliability data
# Store the selected counties in a variable called selected_counties
# Display the selected counties with their key characteristics
# Show: county name, median income, MOE percentage, reliability category
county_reliability %>%
dplyr::select(county, med_incomeE, income_moe_pct, reliability) %>%
dplyr::arrange(income_moe_pct)
# ---- 3.1: pick counties for tract-level study ----
selected_counties <- county_reliability %>%
dplyr::filter(county %in% c("Kings", "Greene", "Hamilton")) %>%
dplyr::select(county, GEOID, med_incomeE, income_moe_pct, reliability)
knitr::kable(
selected_counties,
caption = "Selected counties for tract-level analysis"
)
# ---- 3.2: Tract-level demographics (robust county naming via FIPS) ----
# 1) Variables
vars_tracts <- c(
white_nh  = "B03002_003",  # White alone, not Hispanic or Latino
black_nh  = "B03002_004",  # Black alone, not Hispanic or Latino
hispanic  = "B03002_012",  # Hispanic or Latino
total_pop = "B03002_001"   # Total population
)
# 2) 3-digit county FIPS from your selected counties (5-digit GEOID -> last 3)
county_codes3 <- stringr::str_sub(selected_counties$GEOID, -3, -1) %>% unique()
# 3) Pull ACS tract-level data
tract_raw <- tidycensus::get_acs(
geography = "tract",
variables = vars_tracts,
year      = acs_year,
survey    = "acs5",
state     = my_state,
county    = county_codes3,
output    = "wide"
)
# 4) Derive state/county FIPS from the tract GEOID and join to official names
#    tract GEOID = SS + CCC + TTTTTT  (state 2, county 3, tract 6)
tract_demo <- tract_raw %>%
dplyr::mutate(
state_fips  = stringr::str_sub(GEOID, 1, 2),
county_fips = stringr::str_sub(GEOID, 3, 5),
tract_label = stringr::str_extract(NAME, "^Census Tract\\s*[^,]+") %>%
stringr::str_remove("^Census Tract\\s*")
) %>%
dplyr::left_join(
tidycensus::fips_codes %>%
dplyr::transmute(
state_fips  = state_code,
county_fips = county_code,
county_label = county,   # e.g., "Kings"
state_label  = state     # e.g., "New York"
),
by = c("state_fips", "county_fips")
) %>%
# 5) Compute percentages
dplyr::mutate(
pct_white_nh = dplyr::if_else(total_popE > 0, 100 * white_nhE / total_popE, NA_real_),
pct_black_nh = dplyr::if_else(total_popE > 0, 100 * black_nhE / total_popE, NA_real_),
pct_hispanic = dplyr::if_else(total_popE > 0, 100 * hispanicE / total_popE, NA_real_)
)
# Quick peek
knitr::kable(
tract_demo %>%
dplyr::select(
GEOID, tract_label, county_label,
total_popE, white_nhE, pct_white_nh,
black_nhE, pct_black_nh,
hispanicE, pct_hispanic
) %>% head(10),
caption = "Tract demographics with population percentages (first 10 rows)",
digits = 1
)
# ---- 3.3A: tract with highest % Hispanic ----
top_hispanic_tract <- tract_demo %>%
dplyr::filter(!is.na(pct_hispanic)) %>%
dplyr::arrange(dplyr::desc(pct_hispanic)) %>%
dplyr::slice(1) %>%
dplyr::select(
GEOID, tract_label, county_label,
total_popE, pct_white_nh, pct_black_nh, pct_hispanic
)
knitr::kable(
top_hispanic_tract,
digits = c(0, 0, 0, 0, 1, 1, 1),
caption = "Tract with the highest % Hispanic"
)
# ---- 3.3B: summarize by county (population-weighted) ----
county_summary_weighted <- tract_demo %>%
dplyr::group_by(county_label) %>%
dplyr::summarise(
total_pop = sum(total_popE, na.rm = TRUE),
white_nh  = sum(white_nhE,  na.rm = TRUE),
black_nh  = sum(black_nhE,  na.rm = TRUE),
hispanic  = sum(hispanicE,  na.rm = TRUE),
n_tracts  = dplyr::n(),
.groups = "drop"
) %>%
dplyr::mutate(
pct_white_nh = 100 * white_nh / total_pop,
pct_black_nh = 100 * black_nh / total_pop,
pct_hispanic = 100 * hispanic / total_pop
) %>%
dplyr::select(
county_label, n_tracts, total_pop,
pct_white_nh, pct_black_nh, pct_hispanic
)
knitr::kable(
county_summary_weighted,
digits = c(0, 0, 0, 1, 1, 1),
col.names = c("County", "Tracts", "Population",
"% White (NH)", "% Black (NH)", "% Hispanic"),
caption = "County-wide demographics (ACS 2018–2022 5-year, weighted by population)"
)
# ---- 4.1: MOE analysis for demographic variables ----
# Safety: ensure tract_demo exists
stopifnot(exists("tract_demo"))
tract_moe <- tract_demo %>%
dplyr::mutate(
# MOE% for each group (only when estimate > 0 and MOE available)
white_moe_pct    = dplyr::if_else(!is.na(white_nhE)  & white_nhE  > 0 & !is.na(white_nhM),
100 * white_nhM  / white_nhE,  NA_real_),
black_moe_pct    = dplyr::if_else(!is.na(black_nhE)  & black_nhE  > 0 & !is.na(black_nhM),
100 * black_nhM  / black_nhE,  NA_real_),
hispanic_moe_pct = dplyr::if_else(!is.na(hispanicE)  & hispanicE  > 0 & !is.na(hispanicM),
100 * hispanicM  / hispanicE,  NA_real_),
# Per-group >15% flags
over15_white = white_moe_pct    > 15,
over15_black = black_moe_pct    > 15,
over15_hisp  = hispanic_moe_pct > 15,
# Any group over threshold
high_moe_flag = over15_white | over15_black | over15_hisp
)
# Overall summary
tract_moe_summary <- tract_moe %>%
dplyr::summarise(
total_tracts    = dplyr::n(),
high_moe_tracts = sum(high_moe_flag, na.rm = TRUE),
pct_high_moe    = round(100 * high_moe_tracts / total_tracts, 1),
# count tracts where at least one MOE% couldn't be computed
any_moe_na      = sum(is.na(white_moe_pct) | is.na(black_moe_pct) | is.na(hispanic_moe_pct))
)
knitr::kable(
tract_moe_summary,
digits = 1,
caption = "Summary of high-MOE tracts (ACS 2018–2022 5-year)"
)
# ---- 4.2A: Compare tracts with vs. without high MOE issues ----
pattern_analysis <- tract_moe %>%
dplyr::group_by(high_moe_flag) %>%
dplyr::summarise(
n_tracts         = dplyr::n(),
avg_pop          = mean(total_popE, na.rm = TRUE),
avg_pct_white    = mean(pct_white_nh, na.rm = TRUE),
avg_pct_black    = mean(pct_black_nh, na.rm = TRUE),
avg_pct_hispanic = mean(pct_hispanic, na.rm = TRUE),
.groups = "drop"
)
knitr::kable(
pattern_analysis,
digits = 1,
col.names = c("High MOE Flag", "Tracts", "Avg Pop",
"Avg % White (NH)", "Avg % Black (NH)", "Avg % Hispanic"),
caption = "Comparison of tracts with vs. without high MOE issues"
)
# ---- 4.2B: Count MOE>15% flags by county ----
flags_by_county <- tract_moe %>%
dplyr::group_by(county_label) %>%
dplyr::summarise(
white_flags    = sum(over15_white,    na.rm = TRUE),
black_flags    = sum(over15_black,    na.rm = TRUE),
hispanic_flags = sum(over15_hisp,     na.rm = TRUE),
total_tracts   = dplyr::n(),
any_high_moe   = sum(high_moe_flag,   na.rm = TRUE),
pct_flagged    = round(100 * any_high_moe / total_tracts, 1),
.groups = "drop"
) %>%
dplyr::arrange(dplyr::desc(pct_flagged))
knitr::kable(
flags_by_county,
digits = 1,
caption = "Tracts with MOE% > 15% by county (counts and % of tracts flagged)"
)
# Create a summary table using your county reliability data
# Include: county name, median income, MOE percentage, reliability category
# Add a new column with algorithm recommendations using case_when():
# - High Confidence: "Safe for algorithmic decisions"
# - Moderate Confidence: "Use with caution - monitor outcomes"
# - Low Confidence: "Requires manual review or additional data"
# Format as a professional table with kable()
# ---- Decision framework table (minimal + robust) ----
library(dplyr)
library(knitr)
decision_tbl <- county_reliability %>%
# keep rows where we can actually decide something
filter(!is.na(med_incomeE), !is.na(income_moe_pct)) %>%
# If your data already has `reliability`, we’ll use it; otherwise derive it from MOE%
mutate(
reliability = case_when(
!is.na(reliability) ~ reliability,
income_moe_pct <= 5     ~ "High Confidence",
income_moe_pct <= 10    ~ "Moderate Confidence",
TRUE                    ~ "Low Confidence"
),
# Map reliability -> implementation recommendation
recommendation = case_when(
reliability == "High Confidence"      ~ "Safe for algorithmic decisions",
reliability == "Moderate Confidence"  ~ "Use with caution - monitor outcomes",
reliability == "Low Confidence"       ~ "Requires manual review or additional data",
TRUE                                  ~ "Review needed"
),
# Pretty formatting for display only
`Median income ($)` = formatC(med_incomeE, format = "f", digits = 0, big.mark = ","),
`Income MOE %` = sprintf("%.1f%%", income_moe_pct),
# Order rows by reliability (High → Moderate → Low)
reliability = factor(reliability, levels = c("High Confidence","Moderate Confidence","Low Confidence"))
) %>%
transmute(
County = county,
`Median income ($)`,
`Income MOE %`,
Reliability = reliability,
Recommendation = recommendation
) %>%
arrange(Reliability, County)
knitr::kable(
decision_tbl,
caption = "Decision Framework for Algorithm Implementation (ACS 2022 5-year)"
)
# ---- Decision framework table (minimal + robust) ----
library(dplyr)
library(knitr)
decision_tbl <- county_reliability %>%
# keep rows where we can actually decide something
filter(!is.na(med_incomeE), !is.na(income_moe_pct)) %>%
# If your data already has `reliability`, we’ll use it; otherwise derive it from MOE%
mutate(
reliability = case_when(
!is.na(reliability) ~ reliability,
income_moe_pct <= 5     ~ "High Confidence",
income_moe_pct <= 10    ~ "Moderate Confidence",
TRUE                    ~ "Low Confidence"
),
# Map reliability -> implementation recommendation
recommendation = case_when(
reliability == "High Confidence"      ~ "Safe for algorithmic decisions",
reliability == "Moderate Confidence"  ~ "Use with caution - monitor outcomes",
reliability == "Low Confidence"       ~ "Requires manual review or additional data",
TRUE                                  ~ "Review needed"
),
# Pretty formatting for display only
`Median income ($)` = formatC(med_incomeE, format = "f", digits = 0, big.mark = ","),
`Income MOE %` = sprintf("%.1f%%", income_moe_pct),
# Order rows by reliability (High → Moderate → Low)
reliability = factor(reliability, levels = c("High Confidence","Moderate Confidence","Low Confidence"))
) %>%
transmute(
County = county,
`Median income ($)`,
`Income MOE %`,
Reliability = reliability,
Recommendation = recommendation
) %>%
arrange(Reliability, County)
knitr::kable(
decision_tbl,
caption = "Decision Framework for Algorithm Implementation (ACS 2022 5-year)"
)
# Load required packages (hint: you need tidycensus, tidyverse, and knitr)
# Set your Census API key
# Choose your state for analysis - assign it to a variable called my_state
# ---- Decision framework table (minimal + robust) ----
library(dplyr)
library(knitr)
decision_tbl <- county_reliability %>%
# keep rows where we can actually decide something
filter(!is.na(med_incomeE), !is.na(income_moe_pct)) %>%
# If your data already has `reliability`, we’ll use it; otherwise derive it from MOE%
mutate(
reliability = case_when(
!is.na(reliability) ~ reliability,
income_moe_pct <= 5     ~ "High Confidence",
income_moe_pct <= 10    ~ "Moderate Confidence",
TRUE                    ~ "Low Confidence"
),
# Map reliability -> implementation recommendation
recommendation = case_when(
reliability == "High Confidence"      ~ "Safe for algorithmic decisions",
reliability == "Moderate Confidence"  ~ "Use with caution - monitor outcomes",
reliability == "Low Confidence"       ~ "Requires manual review or additional data",
TRUE                                  ~ "Review needed"
),
# Pretty formatting for display only
`Median income ($)` = formatC(med_incomeE, format = "f", digits = 0, big.mark = ","),
`Income MOE %` = sprintf("%.1f%%", income_moe_pct),
# Order rows by reliability (High → Moderate → Low)
reliability = factor(reliability, levels = c("High Confidence","Moderate Confidence","Low Confidence"))
) %>%
transmute(
County = county,
`Median income ($)`,
`Income MOE %`,
Reliability = reliability,
Recommendation = recommendation
) %>%
arrange(Reliability, County)
knitr::kable(
decision_tbl,
caption = "Decision Framework for Algorithm Implementation (ACS 2022 5-year)"
)
