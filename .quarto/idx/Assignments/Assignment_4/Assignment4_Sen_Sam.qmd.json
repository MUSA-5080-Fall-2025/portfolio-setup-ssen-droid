{"title":"Lab Assignment 4: Spatial Predictive Analysis","markdown":{"headingText":"Lab Assignment 4: Spatial Predictive Analysis","containsRefs":false,"markdown":"**MUSA 5080 - Fall 2025**\n**Sam Sen** \n\n---\n\n## Introduction \nThis report will explore Rodent Baiting requests in the Chicago area. I have selected this set to see if there are spatial patterns associated with rodent baiting requests, and understand where requests occur most often. This information could be used to help allocate city resources. It is also important to note that just because a specific area has many requests doesn't necessarily mean that that area suffers more from rodent infestations. This is much like the predicament of predictive policing. It is very possible that wealthier neighborhoods file more complaints while poorer neighborhoods fail to report rodent sightings. This report will not explore additional demographic datasets in order to address these questions, but it is important to keep in mind as this report is analyzed. \n\n## Violation Selection: Rodent Baiting\n\n```{r}\nlibrary(tidyverse)\nlibrary(janitor)\n\nrodent <- readr::read_csv(\"Data/Rodent.csv\") %>%\n  janitor::clean_names()\n\nglimpse(rodent)\nnrow(rodent)\n\n\n\n\n```\n### Explanation \nThe violation selection code narrows the massive 311 dataset down to one type of service request and one year of observations.That subset becomes the input for all later steps (fishnet aggregation, modeling, cross-validation, KDE baseline).\n\n\n## Data Loading & Exploration\n\n```{r}\n# Parse the text dates, then keep only 2017 rows with valid coordinates\nrodent_2017 <- rodent %>%\n  mutate(creation_date = lubridate::mdy(creation_date)) %>%  # \"12/18/2018\" -> Date\n  filter(lubridate::year(creation_date) == 2017,              # only 2017\n         !is.na(latitude), !is.na(longitude))                 # drop missing coords\n\n# quick checks\nnrow(rodent_2017)\nsummary(rodent_2017$creation_date)\n\n```\n```{r}\nlibrary(sf)\n\n# Convert to an sf (spatial) object\nrodent_sf <- st_as_sf(\n  rodent_2017,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326  # WGS84 coordinate system (standard lat/long)\n)\n\n# Check structure\nrodent_sf\n\n```\n\n```{r}\n# needs: library(ggplot2); library(sf)\n# assumes you already have rodent_sf (2017 points as sf in EPSG:4326)\n\nggplot() +\n  geom_sf(data = rodent_sf, color = \"firebrick\", alpha = 0.15, size = 0.20) +\n  labs(\n    title = \"Rodent Baiting Requests (2017) — Points\",\n    subtitle = \"Each point = one 311 request\",\n    caption = \"Source: City of Chicago 311\"\n  ) +\n  theme_void()\n\n\n\n```\n```{r}\nset.seed(1)\nrodent_sample <- dplyr::slice_sample(rodent_sf, n = 10000)\n\nggplot() +\n  geom_sf(data = rodent_sample, color = \"firebrick\", alpha = 0.25, size = 0.25) +\n  labs(title = \"Rodent Baiting (2017) — Sample of 10k points\") +\n  theme_void()\n\n```\n### Obersvations \nThere are an alarming number of rodent baiting requests throughout the city of Chicago, with the north side of Chicago in particular looking very dense. However, without a density map, it is hard to differentiate between the dark clusters of red. The south side of Chicago clearly has more sparse data with regard to rodent baiting requests. The following section will employ fishnet grid creation to better understand the spatial data. \n\n## Fishnet Grid Creation\n\n```{r}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tigris)\nlibrary(ggplot2)\nlibrary(viridis)\noptions(tigris_use_cache = TRUE, tigris_class = \"sf\")\n\n# Chicago boundary (robust filter), then keep only the main polygon; project to meters\nil_places <- places(state = \"IL\", cb = TRUE, year = 2020)\nchi_city <- il_places %>%\n  filter(NAME == \"Chicago\" | NAME == \"Chicago city\" | grepl(\"^Chicago\", NAMELSAD)) %>%\n  st_make_valid() %>%\n  st_cast(\"POLYGON\") %>%\n  mutate(area = st_area(.)) %>%\n  slice_max(area, n = 1) %>%\n  st_transform(3857)\n\n\n\n```\n```{r}\n# Regular 500 m grid covering Chicago’s extent\ngrid_raw <- st_make_grid(chi_city, cellsize = 500, square = TRUE) %>%\n  st_as_sf() %>%\n  mutate(grid_id = dplyr::row_number())\n\n# Keep only cells whose centroids fall inside the city (drop outside)\ngrid_500 <- grid_raw[ st_within(st_centroid(grid_raw), chi_city, sparse = FALSE)[,1], ]\n\n```\n```{r}\n# Ensure points are in meters to match the grid/boundary\nrodent_3857 <- st_transform(rodent_sf, 3857)\n\n# Count points per cell (fast: use st_intersects + lengths)\ngrid_agg <- grid_500 %>%\n  mutate(count = lengths(st_intersects(., rodent_3857)))\n\n```\n\n```{r}\nbb <- st_bbox(chi_city)\n\n# Map of counts per 500 m cell (sqrt stretch makes mid-range visible)\nggplot() +\n  geom_sf(data = grid_agg, aes(fill = count), color = NA) +\n  geom_sf(data = chi_city, fill = NA, color = \"grey35\", linewidth = 0.4, inherit.aes = FALSE) +\n  coord_sf(crs = 3857,\n           xlim = c(bb[\"xmin\"], bb[\"xmax\"]),\n           ylim = c(bb[\"ymin\"], bb[\"ymax\"]),\n           expand = FALSE) +\n  scale_fill_viridis_c(trans = \"sqrt\", name = \"Requests / cell\") +\n  labs(title = \"Rodent Baiting (2017) — Counts per 500 m Cell\",\n       subtitle = \"Fishnet aggregation across Chicago\",\n       caption = \"Source: City of Chicago 311; Boundary: US Census TIGER/Line\") +\n  theme_void() +\n  theme(legend.position = \"right\")\n\n# Quick histogram of cell counts (skews right; many zeros, few hotspots)\nggplot(st_drop_geometry(grid_agg), aes(x = count)) +\n  geom_histogram(binwidth = 1, boundary = 0) +\n  scale_y_continuous(labels = scales::comma) +\n  labs(title = \"Distribution of Requests per 500 m Cell\",\n       x = \"Requests in cell\", y = \"Number of cells\") +\n  theme_minimal()\n\n```\n\n### Obersvations\nThe above fisnhnet aggregation helps smooth over the rodent baiting point map in the previous section by displaying # of requests per grid cell. In essence, we have created a fishnet grid where every 500 square meters is a grid cell. From here, we can look at counts per grid cells rather than just thousands of points which is hard to interpret. This visualization makes it easier to evaluate counts accross space and provides a better sense of density of requests. The above map clearly shows high counts particular clustered in the north side of Chicago. \n\n\n## Spatial Features\nIn this section we will create a k-nearest neighbors feature and look at average counts of each grid cells 5 nearest neighbors. We will equally weight the neighbors counts and compute the average. We will then conduct Local Moran's I analysis in the subsequent section and add our second feature - a distance measure - that will be further explained in that section.   \n\n```{r}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(spdep)\n\n```\n\n```{r}\ngrid_agg_3857 <- st_transform(grid_agg, 3857)\n\n```\n\n```{r}\ncentroids <- st_centroid(grid_agg_3857)\nxy <- st_coordinates(centroids)\nknn5 <- knearneigh(xy, k = 5)\nnb5  <- knn2nb(knn5)\nlw5  <- nb2listw(nb5, style = \"W\", zero.policy = TRUE)\n\n\n```\n\n```{r}\n# Convert neighbor list into a weights matrix\nweights_5 <- spdep::nb2listw(nb5, style = \"W\")\n\n# Calculate spatial lag (mean count of 5 nearest neighbors)\ngrid_agg_3857$lag5_mean <- spdep::lag.listw(weights_5, grid_agg_3857$count)\n\n```\n\n```{r}\nlibrary(ggplot2)\nlibrary(viridis)\n\nggplot(grid_agg_3857) +\n  geom_sf(aes(fill = lag5_mean), color = NA) +\n  scale_fill_viridis_c(name = \"Avg Neighbor Count\", trans = \"sqrt\") +\n  labs(\n    title = \"Rodent Baiting — Mean Count of 5 Nearest Neighbor Cells\",\n    subtitle = \"Spatial lag feature (k = 5)\",\n    caption = \"Source: City of Chicago 311\"\n  ) +\n  theme_void()\n\n```\n### Explanation \nThe above map displays our first feature - k-NN. Each grid cell is displaying the mean of its 5 nearest neighbored weighted equally. Visually, there appears to be spatial autocorrelation, with high counts surrounded by high counts and low counts surrounded by low counts. However, statistical significance of this apparent autocorrelation cannot be determined without computing Moran's I. The next step with look at Local Moran's I to evaluate the signifiance of this observed spatial autocorrelation. \n\n## Local Moran's I \n```{r}\n# --- Local Moran’s I: Hot/Cold Spot Analysis ---\nlibrary(spdep)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n#Compute Local Moran’s I for the counts\nlocI <- localmoran(grid_agg_3857$count, lw5, zero.policy = TRUE)\n\n#Attach results\ngrid_agg_3857 <- grid_agg_3857 %>%\n  mutate(\n    Ii = locI[, 1],          # Local Moran’s I value\n    Ei = locI[, 2],          # Expected value\n    Vi = locI[, 3],          # Variance\n    Z  = (Ii - Ei) / sqrt(Vi), # Z-score\n    Pr = locI[, 5]           # p-value\n  )\n\n#Classify each cell (significant clusters/outliers)\nz_count <- as.numeric(scale(grid_agg_3857$count))\nz_lag   <- as.numeric(scale(grid_agg_3857$lag5_mean))\nsig     <- grid_agg_3857$Pr < 0.05\n\ngrid_agg_3857$quad <- dplyr::case_when(\n  z_count >= 0 & z_lag >= 0 & sig ~ \"High-High (Hot Spot)\",\n  z_count <  0 & z_lag <  0 & sig ~ \"Low-Low (Cold Spot)\",\n  z_count >= 0 & z_lag <  0 & sig ~ \"High-Low (Outlier)\",\n  z_count <  0 & z_lag >= 0 & sig ~ \"Low-High (Outlier)\",\n  TRUE ~ \"Not Significant\"\n)\n\n#Plot hot/cold spots\nggplot(grid_agg_3857) +\n  geom_sf(aes(fill = quad), color = NA) +\n  scale_fill_manual(\n    values = c(\n      \"High-High (Hot Spot)\"  = \"#b2182b\",\n      \"Low-Low (Cold Spot)\"   = \"#2166ac\",\n      \"High-Low (Outlier)\"    = \"#ef8a62\",\n      \"Low-High (Outlier)\"    = \"#67a9cf\",\n      \"Not Significant\"       = \"grey90\"\n    ),\n    name = \"Local Moran’s I\"\n  ) +\n  labs(\n    title    = \"Local Moran’s I — Rodent Baiting Requests (2017)\",\n    subtitle = \"Significant clusters (p < 0.05) using k = 5 nearest neighbors\",\n    caption  = \"Source: City of Chicago 311\"\n  ) +\n  theme_void() +\n  theme(legend.position = \"right\")\n\n```\n### Explanation\nIn general, the clustering of high-high values in the north side of Chicago is significant (hot spots). The Low-low clustering that we observed in the previous map is not spatially significant per Local Moran's I. This could be due to 0s and lack of observations. The north and southwest parts of the city sow clusters of high rodent complaints. These may correspond to dense residential neighborhoods. The central and outer areas show few significant clusters, possibly due to lower population density or lack of reporting due to other factors including demographic. \n\n## Additional Spatial Feature (Distance Measures)\nHere we will add feature and visualization that shows each grid cells distance to the nearest hotspot. \n\n```{r}\nlibrary(sf)\nlibrary(dplyr)\n\n# 1️⃣ Separate the hot spot cells\nhotspots <- grid_agg_3857 %>% \n  filter(quad == \"High-High (Hot Spot)\")\n\n# 2️⃣ Calculate distance from every cell centroid to nearest hot spot centroid\ncentroids <- st_centroid(grid_agg_3857)\nhot_centroids <- st_centroid(hotspots)\n\n# st_distance creates a distance matrix (each cell vs each hot spot)\ndist_matrix <- st_distance(centroids, hot_centroids)\n\n# 3️⃣ Take the minimum distance per cell (convert from meters to km)\ngrid_agg_3857$dist_to_hotspot_km <- apply(dist_matrix, 1, min) / 1000\n\n```\n\n```{r}\nlibrary(ggplot2)\nlibrary(viridis)\n\nggplot(grid_agg_3857) +\n  geom_sf(aes(fill = dist_to_hotspot_km), color = NA) +\n  scale_fill_viridis_c(name = \"Distance to nearest hot spot (km)\", trans = \"sqrt\") +\n  labs(\n    title = \"Distance to Nearest Hot Spot — Rodent Baiting (2017)\",\n    subtitle = \"Each 500 m cell colored by distance from significant hot spots\",\n    caption = \"Source: City of Chicago 311; Hot spots from Local Moran’s I\"\n  ) +\n  theme_void() +\n  theme(legend.position = \"right\")\n\n```\n### Explanation \nThe above gradient map shows grid cells that are far from hot spots in light yellow and grid cells that are closer to hotspots in blue. As expected, the south side of Chicago is largely yellow due to the low number of rodent baiting requests, while the north side of Chicago displays dark blue. This can be simply interpreted by saying the south side of Chicago tends to have grid cells that are far away from hotspots and as one moves north their distance to the nearest hotspot decreases. \n\n## Count Regression Models\n\nIn this section we will first fit a Poisson Regression and then a negative binomial regression. We have created two predictors from the previous sections - k-NN and our distance measure - and our dependent variable is the number of rodent baiting reqests in a given grid cell. Since the dependent variable is a count (# of baiting requests) we cannot use simple regresison. \n\n### Poisson Regression \n```{r}\n# Predictors we created in Part 3:\n# - lag5_mean (avg of 5 nearest neighbors)\n# - dist_to_hotspot_km (distance to nearest hot spot)\n\nstopifnot(all(c(\"count\",\"lag5_mean\",\"dist_to_hotspot_km\") %in% names(grid_agg_3857)))\n\n# (optional but helpful) replace any tiny NAs with 0s for modeling\ngrid_mod <- grid_agg_3857 |>\n  dplyr::mutate(\n    lag5_mean = ifelse(is.na(lag5_mean), 0, lag5_mean),\n    dist_to_hotspot_km = ifelse(is.na(dist_to_hotspot_km), 0, dist_to_hotspot_km)\n  )\n\n```\n\n```{r}\n# Poisson regression with log link (default)\nm_pois <- glm(\n  count ~ lag5_mean + dist_to_hotspot_km,\n  data = grid_mod,\n  family = poisson(link = \"log\")\n)\n\nsummary(m_pois)\n\n```\n```{r}\nexp(coef(m_pois))\n\n\n```\n\n### Negative Binomial Regression \n```{r}\n# install.packages(\"MASS\")  # if not installed\nlibrary(MASS)\nlibrary(broom)\n\nm_nb <- glm.nb(count ~ lag5_mean + dist_to_hotspot_km, data = grid_mod)\nsummary(m_nb)\n\n```\n\n```{r}\nAIC(m_pois, m_nb)\n\n```\n\n### Explanation \nThe Poisson regression assumes that mean=variance, which is likley unrealistic given that many cells have 0 counts while some cells have extremely high counts. Negative Binomial regression relaxes this assumption by adding a parameter that allows variance to exceed mean. In comparing AICs of both models, the Negative Binomial model appears to be a better fit which is expected given the highy variance in the data.  \n\n## Spatial Cross-Validation (2017)\n\n```{r}\n#Part 5 — Step 1: assign each grid cell to a spatial group (Census tract)\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tigris)\noptions(tigris_use_cache = TRUE, tigris_class = \"sf\")\n\n#Load Cook County tracts and keep just the tract ID\ncook_tracts <- tigris::tracts(state = \"IL\", county = \"Cook\", cb = TRUE, year = 2017) %>%\n  st_transform(3857) %>%\n  dplyr::select(GEOID)  # explicitly use dplyr::select()\n\n#Get centroids for grid (points for joining)\ngrid_cent <- st_centroid(grid_agg_3857)\n\n#Spatial join: assign each centroid to its containing tract polygon\ngrid_with_group <- st_join(grid_cent, cook_tracts, left = TRUE)\n\n#Copy GEOID (the tract ID) into grid object as group_id\ngrid_agg_3857$group_id <- grid_with_group$GEOID\n\n#Sanity checks\ncat(\"Unique tracts assigned:\", length(unique(na.omit(grid_agg_3857$group_id))), \"\\n\")\ncat(\"Unassigned cells:\", sum(is.na(grid_agg_3857$group_id)), \"\\n\")\n\n\n```\n\n```{r}\n# Part 5 — Step 2: define function for one iteration of LOGO CV\n\nlibrary(MASS)     # for glm.nb\nlibrary(Metrics)  # for mae() and rmse()\n\nrun_logo <- function(test_group, data) {\n  # Split data into training and testing based on group_id\n  train_data <- data[data$group_id != test_group, ]\n  test_data  <- data[data$group_id == test_group, ]\n  \n  # Fit Negative Binomial model \n  model <- glm.nb(count ~ lag5_mean + dist_to_hotspot_km, data = train_data)\n  \n  # Predict for held-out group\n  preds <- predict(model, newdata = test_data, type = \"response\")\n  \n  # Calculate error metrics for that group\n  data.frame(\n    group_id = test_group,\n    MAE  = mae(test_data$count, preds),\n    RMSE = rmse(test_data$count, preds)\n  )\n}\n```\n\n```{r}\n# Part 5 — Step 3: choose valid test groups (tracts with enough cells)\n\nlibrary(dplyr)\n\n# cells per tract\ngroup_summary <- grid_agg_3857 |>\n  st_drop_geometry() |>\n  filter(!is.na(group_id)) |>\n  count(group_id, name = \"n_cells\")\n\n# distribution of tract sizes (sanity check)\nsize_dist <- group_summary |>\n  count(n_cells, name = \"num_tracts\") |>\n  arrange(n_cells)\nprint(size_dist)\n\n# pick tracts with >= 5 cells as testable groups\nvalid_groups <- group_summary |>\n  filter(n_cells >= 5) |>\n  pull(group_id)\n\n# dataset restricted to those groups for testing (training will still see ALL groups in each fold)\ngrid_valid <- grid_agg_3857 |>\n  filter(group_id %in% valid_groups)\n\n# quick coverage stats\ncat(\"Total tracts:\", nrow(group_summary), \"\\n\")\ncat(\"Valid test tracts (>=5 cells):\", length(valid_groups), \"\\n\")\ncat(\"Cells in valid test tracts:\", nrow(grid_valid), \"of\", nrow(grid_agg_3857), \"\\n\")\ncat(\"Coverage of cells for testing:\", round(100 * nrow(grid_valid)/nrow(grid_agg_3857), 1), \"%\\n\")\n\n```\n\n```{r}\n# Part 5 — Step 4: quick sanity run on 10 valid tracts\ntest_groups <- valid_groups[1:10]\n\ncv_results_small <- do.call(\n  rbind,\n  lapply(test_groups, run_logo, data = grid_valid)\n)\n\n# View first few results and overall averages\nhead(cv_results_small)\nmean(cv_results_small$MAE, na.rm = TRUE)\nmean(cv_results_small$RMSE, na.rm = TRUE)\n\n```\n```{r}\n# Part 5 — Step 5: full Leave-One-Group-Out CV over all valid tracts\ncv_results <- do.call(\n  rbind,\n  lapply(valid_groups, run_logo, data = grid_valid)\n)\n\n# Save + summarize\nhead(cv_results)\nmean(cv_results$MAE, na.rm = TRUE)\nmean(cv_results$RMSE, na.rm = TRUE)\n\n\n```\n\n```{r}\n# Part 5 — Optional diagnostic: visualize CV errors by tract\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(viridis)\n\n#Summarize mean MAE per tract (from cv_results)\ncv_summary <- cv_results |>\n  group_by(group_id) |>\n  summarise(MAE = mean(MAE, na.rm = TRUE),\n            RMSE = mean(RMSE, na.rm = TRUE))\n\n#️Join CV errors back to the tract geometry\ntracts_errors <- cook_tracts |>\n  left_join(cv_summary, by = c(\"GEOID\" = \"group_id\"))\n\n#Plot MAE across tracts\nggplot(tracts_errors) +\n  geom_sf(aes(fill = MAE), color = NA) +\n  scale_fill_viridis_c(option = \"C\", name = \"Mean Absolute Error\") +\n  labs(\n    title = \"Cross-Validated MAE by Census Tract\",\n    subtitle = \"Leave-One-Group-Out CV (Negative Binomial Model)\",\n    caption  = \"Source: City of Chicago 311 Rodent Baiting Data, 2017\"\n  ) +\n  theme_void() +\n  theme(legend.position = \"right\")\n\n```\n### Explanation\nTo evaluate predictive performance, the above analysis implemented a Leave-One-Group-Out Cross-Validation (LOGO-CV) using Census tracts as spatial folds. Each iteration trained the Negative Binomial model on all tracts except one and predicted the held-out tract, producing tract-level Mean Absolute Error (MAE) and Root Mean Squared Error (RMSE) values. On average, the model achieved MAE ≈ 15 and RMSE ≈ 19, indicating that predictions typically differed from observed counts by about 15 rodent requests per 500 m cell. The MAE map shows that most tracts have relatively low error (dark purple), while a few in the north and west sides exhibit higher MAE (yellow), suggesting localized variation in reporting patterns or unmodeled neighborhood effects. These are the areas where there were significant clusters of hotspots where some hotspots had extreme values. \n\n## Model Evaluation\nThe following section well compare our LOGO-CV to KDE baseline. KDE is a simple heatmap of rodent activity that spreads all the point data into a smooth \"bump\" of intensity over the city. When all these bumps overlap we get a continuous density surface. \n\n```{r}\n# --- Part 6: KDE baseline ---\n# Step 1: Setup (packages, points, boundary, window, ppp)\n\n# 1) Load required packages\n# install.packages(\"spatstat\")  # run once if not yet installed\nlibrary(spatstat)   # brings in spatstat.geom/core/etc.\nlibrary(sf)\nlibrary(dplyr)\n\n# 2) Use your existing 2017 rodent points\nrodent_sf_2017 <- rodent_sf\n\n# 3) Make sure the points are projected to meters (EPSG:3857)\nrodent_pts_3857 <- if (sf::st_is_longlat(rodent_sf_2017)) {\n  sf::st_transform(rodent_sf_2017, 3857)\n} else {\n  rodent_sf_2017\n}\n\n# 4) Create a boundary polygon from your grid\nboundary_sfc <- sf::st_union(sf::st_geometry(grid_agg_3857))   # returns sfc_MULTIPOLYGON\nboundary_sfc <- sf::st_make_valid(boundary_sfc)\n\n# 5) Convert boundary to a spatstat window\nwin_3857 <- spatstat.geom::as.owin(boundary_sfc)\n\n# 6) Convert the rodent points into a spatstat ppp (point pattern)\ncoords <- sf::st_coordinates(rodent_pts_3857)\npp <- spatstat.geom::ppp(x = coords[,1], y = coords[,2], window = win_3857)\n\n# 7) Sanity check outputs\ncat(\"Point pattern:\", pp$n, \"events in window\\n\")\ncat(\"Window area (sq. km):\", round(spatstat.geom::area.owin(win_3857) / 1e6, 1), \"\\n\")\n\n\n```\n```{r}\n# --- Part 6: KDE baseline ---\n# Step 2: choose bandwidth, compute KDE, extract to grid, score\n\nlibrary(spatstat)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(Metrics)  # for mae(), rmse()\n\n# pp  = your point pattern (from prior step)\n# grid_agg_3857 = your fishnet with 'count' column (observed)\n\n# 1) Automatic bandwidth selection (Diggle’s method is a good default)\nbw <- bw.diggle(pp)   # you can also try: bw.ppl(pp) or bw.scott(pp)\ncat(\"Chosen bandwidth (meters):\", round(bw, 1), \"\\n\")\n\n# 2) KDE intensity image (events per square meter)\n#    edge=TRUE applies edge correction; leaveat defaults to pixel grid\ndens_im <- density.ppp(pp, sigma = bw, edge = TRUE)\n\n# 3) Get grid centroids (to sample the KDE at each cell)\ngrid_cent <- st_centroid(grid_agg_3857)\nxy <- st_coordinates(grid_cent)\n\n# 4) Extract KDE intensity at each centroid using nearest pixel lookup\nnp   <- spatstat.geom::nearest.pixel(xy[,1], xy[,2], dens_im)\nkde_intensity <- dens_im$v[cbind(np$row, np$col)]   # units: events per m^2\n\n# 5) Convert intensity (events/m^2) to expected count per grid cell\n#    Cell area in m^2 (assumes square fishnet in EPSG:3857)\ncell_area_m2 <- mean(as.numeric(st_area(grid_agg_3857)))\nkde_pred_count <- pmax(0, kde_intensity * cell_area_m2)  # nonnegative\n\n# 6) Score the KDE baseline against observed counts\nobs <- grid_agg_3857$count\nkde_mae  <- mae(obs, kde_pred_count)\nkde_rmse <- rmse(obs, kde_pred_count)\n\ncat(\"KDE baseline — MAE:\", round(kde_mae, 2), \"\\n\")\ncat(\"KDE baseline — RMSE:\", round(kde_rmse, 2), \"\\n\")\n\n# (Optional) Attach to grid for mapping later\ngrid_agg_3857$kde_pred <- kde_pred_count\n\n```\n### Explanation \nTo benchmark model performance, I compared the Negative Binomial regression against a Kernel Density Estimation (KDE) baseline derived from 2017 rodent-baiting points. The KDE, which smooths event locations into a continuous density surface, achieved MAE ≈ 5 and RMSE ≈ 9 when evaluated on the same data. Although this in-sample baseline yields lower errors, it lacks predictive generalization. By contrast, the cross-validated Negative Binomial model (MAE ≈ 15, RMSE ≈ 19) provides a realistic measure of out-of-sample performance and captures interpretable spatial relationships that a KDE heatmap cannot. However, in order to draw this conclusion of model efficacy, the model must be tested on a new dataset such as 2018. \n\n## Conclusion: Discussion/Analysis \n\nThis report used 2017 Chicago 311 Rodent Baiting requests to model the spatial distribution of rodent activity using a 500 m grid. A Negative Binomial regression incorporating local spatial context (average neighbor count and distance to hot spots) effectively captured the city’s underlying spatial structure of rodent complaints. Cross-validation with Census tracts as spatial folds produced an average MAE of about 15 and RMSE of 19, indicating that model predictions typically deviated from observed counts by roughly 15 complaints per cell. The spatial distribution of errors suggested that predictive accuracy was generally consistent across most neighborhoods, with somewhat higher errors concentrated in parts of the southwest and north sides. This warrants further exploratory analysis and investigation. \n\nTo benchmark performance, the model was compared to a Kernel Density Estimation (KDE) baseline that smoothed event locations into a continuous density surface. Although the KDE baseline achieved lower in-sample error (MAE ≈ 5, RMSE ≈ 9) due to its direct use of observed event data, it lacks the ability to generalize beyond the study year or explain spatial variation through interpretable predictors. In contrast, the regression framework offers a robust, extensible foundation for spatial prediction—capable of assessing new areas or future periods—while providing insight into how neighborhood context influences rodent activity across Chicago. Temporal validation on 2018 data should be conducted as a next step to draw this conclusion. \n\n---\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"Assignment4_Sen_Sam.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.24","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}